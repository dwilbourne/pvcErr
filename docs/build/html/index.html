<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Docutils 0.19: https://docutils.sourceforge.io/" name="generator"/>

    <title>pvcException &#8212; pvcErr documentation</title>
    <link href="_static/pygments.css" rel="stylesheet" type="text/css"/>
    <link href="_static/alabaster.css" rel="stylesheet" type="text/css"/>
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link href="genindex.html" rel="index" title="Index"/>
    <link href="search.html" rel="search" title="Search"/>

    <link href="_static/custom.css" rel="stylesheet" type="text/css"/>


    <meta content="width=device-width, initial-scale=0.9, maximum-scale=0.9" name="viewport"/>

</head>
<body>


<div class="document">
    <div class="documentwrapper">
        <div class="bodywrapper">


            <div class="body" role="main">

                <div class="toctree-wrapper compound">
                </div>
                <section id="pvcexception">
                    <h1>pvcException<a class="headerlink" href="#pvcexception" title="Permalink to this heading">¶</a>
                    </h1>
                    <p>The pvcException package provides an organized (though admittedly unorthodox) approach to
                        constructing and throwing
                        exceptions in php. The pvc libraries use this approach throughout. If you decide you like this
                        approach, the
                        library is constructed with a lightweight hook that allows you to use the same conventions and
                        the pvcException code in
                        your own project.</p>
                    <section id="design-points">
                        <h2>Design Points<a class="headerlink" href="#design-points"
                                            title="Permalink to this heading">¶</a></h2>
                        <ul class="simple">
                            <li><p>It provides a comprehensive way of dealing with exception codes that guarantees
                                uniqueness of codes between packages.
                                Part of value here is that it is easier (less typing) to search logfiles for codes than
                                it is messages.</p></li>
                            <li><p>It provides a set of conventions that makes maintaining exception codes and messages
                                easy.</p></li>
                            <li><p>It implements named parameter substitution into exception message templates. For
                                example, a message template could look like this “Invalid filename: ${filename}”, as
                                opposed to the order-dependent sprintf format “Invalid filename:%s”.</p></li>
                        </ul>
                    </section>
                    <section id="discussion">
                        <h2>Discussion<a class="headerlink" href="#discussion" title="Permalink to this heading">¶</a>
                        </h2>
                        <p>The signature for creating an exception in php provides the exception constructor with a text
                            string (“message”),
                            an integer code (“code”), and the previous exception/error that was thrown (“prev”). One’s
                            first natural
                            inclination is to define new exceptions by extending one of the stock php exceptions (for
                            example, LogicException),
                            and define the class with its own message and code. Something like the following:</p>
                        <div class="highlight-default notranslate">
                            <div class="highlight"><pre><span></span>class myException extends LogicException {

    public function __construct(int $x, Throwable $prev)
    {
        $message = sprintf(&quot;The integer you supplied (%s) must be greater than 0.&quot;, $x);
        $code = 12;

        parent::__construct($message, $code, $prev);
    }
}
</pre>
                            </div>
                        </div>
                        <p>This approach is easy to understand but difficult to manage when you start defining a largish
                            number of exceptions.
                            For one, it’s hard to keep your code numbering system straight. What was the code you used
                            in the last exception
                            that you wrote a couple of days ago? Another challenge is to keep the same style of messages
                            consistent from
                            exception to exception. What is the language style like? Do you want short messages, long
                            messages? What
                            conventions do you use for substituting data values into the message string?</p>
                        <p>Another complexity of managing codes comes up in the context of managing multiple libraries
                            of exceptions. I tend
                            to put all of my exceptions into a single directory for a given set of classes. But if you
                            are constructing a
                            larger application with multiple directories of exceptions or creating multiple
                            packages that need to use a common error code numbering system, you need a mechanism to
                            insure global uniqueness
                            between the directories and packages.</p>
                        <p>pvcException supposes that a “library” of exceptions is a <em>directory</em> that contains
                            exception classes plus an exception
                            data class (XData) that is used to construct the exceptions in that library. This exception
                            data class <em>must extend</em>
                            pvcerrXDataAbstract and must implement the following methods:</p>
                        <div class="highlight-default notranslate">
                            <div class="highlight"><pre><span></span><span class="n">abstract</span> <span class="n">protected</span> <span
                                    class="n">function</span> <span class="n">getLocalXCodes</span><span
                                    class="p">()</span> <span class="p">:</span> <span class="n">array</span><span
                                    class="p">;</span>
<span class="n">abstract</span> <span class="n">protected</span> <span class="n">function</span> <span class="n">getXMessageTemplates</span><span
                                        class="p">():</span> <span class="n">array</span><span class="p">;</span>
</pre>
                            </div>
                        </div>
                        <p>(The naming convention of ‘XCode’ or ‘XMessage’ is simply shorter than typing ‘ExceptionCode’
                            or ‘ExceptionMessage’).</p>
                        <p>The keys in the arrays returned by getXCodes and getXMessageTemplates should be the fully
                            qualified class strings of
                            the exceptions in the library. This convention allows you to take advantage of
                            autocompletion in your IDE. It also
                            allows the code to verify that all the exceptions in the library have codes and messages,
                            that the codes are unique,
                            that there are no “extra exceptions” that have no data, etc.</p>
                        <p>Here is an example of a small exception data class:</p>
                        <div class="highlight-default notranslate">
                            <div class="highlight"><pre><span></span>class _ExceptionData extends XDataAbstract
{
  public function getLocalXCodes() : array
  {
      return [
          InvalidArrayIndexException::class =&gt; 1001,
          InvalidArrayValueException::class =&gt; 1002,
          InvalidFilenameException::class =&gt; 1003,
          InvalidPHPVersionException::class =&gt; 1004,
          PregMatchFailureException::class =&gt; 1005,
          PregReplaceFailureException::class =&gt; 1006,
      ];
  }

        public function getXMessageTemplates() : array
  {
      return [
          InvalidArrayIndexException::class =&gt; &#39;Invalid array index ${index}.&#39;,
          InvalidArrayValueException::class =&gt; &#39;Invalid array value ${value}.&#39;,
          InvalidFilenameException::class =&gt; &#39;filename ${$filename} is not valid.&#39;,
          InvalidPHPVersionException::class =&gt; &#39;Invalid PHP version ${currentVersion} - must be at least ${minVersion}&#39;,
          PregMatchFailureException::class =&gt; &#39;preg_match failed: regex=${regex}; subject=${subject};&#39;,
          PregReplaceFailureException::class =&gt; &#39;preg_replace failed: regex=${regex}; subject=${subject}; replacement=${replacement}&#39;,
      ];
  }
}
</pre>
                            </div>
                        </div>
                        <p>Keeping all the codes and all the message templates in one file makes it far easier to keep
                            local codes and message
                            conventions consistent in the library. You can name the exception data class file anything
                            you want. I typically
                            use a filename that starts with an underscore (“_”) so that the file system automatically
                            sorts it to appear at the
                            top of the directory which is holding my exceptions. As an example, I have a library data
                            class called
                            “_TreeExceptionData”, which is a library for all the exceptions that can be thrown in the
                            course of creating and
                            manipulating an abstract tree structure.</p>
                        <p>Creating the classes for your exceptions is now quite simple. In the same directory in which
                            your exception data
                            class lives, you create “empty exceptions” that extend base exceptions and have a very small
                            footprint. You DO want to
                            provide the construction signature and pass the parameters to the parent class(es). Again,
                            taking advantage of
                            autocompletion in your IDE, this simplifies things when you go to throw an exception in your
                            code. The IDE will
                            prompt you for the parameters, so you don’t have to refer to your exception data file to
                            figure out the name of the
                            parameters.</p>
                        <p>Speaking of parameters, as you can see from the example above, the code uses a template
                            format of “${paramname}”,
                            where paramname is the name of a parameter in the constructor of the exception. Like all of
                            PHP, the names are
                            case-sensitive. Make sure that the dummy variable(s) in the exception constructor match the
                            identifier within the
                            braces of your template variables.</p>
                        <p>The parameters to your exceptions should be scalar and convertible to strings (so typed as
                            strings or int is a good
                            rule of thumb). It will convert booleans to either ‘true’ or ‘false’. If you create a
                            parameter with something more
                            complex, like an object, the library will simply substitute the <em>type</em> of the thing
                            you passed as a parameter into
                            the message.</p>
                        <p>For example, here’s an exception that goes with the example above:</p>
                        <div class="highlight-default notranslate">
                            <div class="highlight"><pre><span></span>use pvc\err\LogicException;

class InvalidArrayIndexException extends LogicException
{
  public function __construct(string $index, Throwable $previous = null)
  {
      parent::__construct($index, $previous);
  }
}
</pre>
                            </div>
                        </div>
                        <p>So when you go to throw this exception, what happens?</p>
                        <p>As you can see, this exception extends LogicException, which is a “pvc branded” exception
                            (hence the “use” statemment
                            in the code block above). LogicException extends Exception, which is the top level exception
                            of pvc exceptions.
                            pvcerrException holds the code that is used to construct the exception code and message. Any
                            exceptions that you
                            write must extend pvcerrException in some way. In general, I want to be able to distinguish
                            between Runtime exceptions and
                            Logic exceptions, so all of the exceptions in the pvc libraries extend one of those two and
                            they are included in this package.
                            Of course you can create additional categorizations if you choose (PDO exception, stream
                            exception, etc).</p>
                        <p>The final task we need to address is how to insure uniqueness of codes between libraries. The
                            basic thought process
                            is that we create a map between namespaces (e.g. libraries) and integer values. Of course,
                            the namespaces
                            correspond to the namespaces of your exception libraries. The prefixes in the array are
                            unique integers. These
                            prefixes will be prepended to the local exception codes defined in your exception library
                            data classes. This is the
                            mechanism that guarantees uniqueness among exception codes.</p>
                        <p>In terms of implementation, there are actually two mechanisms that work in parallel.
                            Internally, pvcExceptions uses
                            a static class to store the namespaces and integers. If you install this package and look in
                            the vendor directory
                            under pvcerrsrc, you will see XCodePrefixes.php.</p>
                        <p>But in order to make the package usable for others, the code looks for an environment
                            variable named “XCodePrefixes”.
                            If such a variable exists, then the value of the variable should be the filepath of
                            <em>your</em> exception code prefixes.
                            In order that I could create this library with no other dependencies, this file must be in
                            php format. Yaml and XML
                            formats would require a dependency on a parser. Json would be a possibility since php can
                            natively parse json, but
                            in the interests of keeping things as simple as possible……</p>
                        <p>Your exception data file should return an array whose form is described above: a series of
                            elements that maps
                            namespaces to integers. For example:</p>
                        <div class="highlight-default notranslate">
                            <div class="highlight"><pre><span></span>&lt;?php

return [
  &#39;my\\namespace&#39; =&gt; 1000,
  &#39;another\\namespace&#39; =&gt; 1001,
]
</pre>
                            </div>
                        </div>
                        <p>pvc reserves the “exception code address space” below 1000. Your exception libraries can use
                            any prefix integers you
                            want so long as they are greater than 999. Using integers less than 1000 will result in an
                            error (well… technically
                            an exception :)</p>
                        <section id="installation-and-dependencies">
                            <h3>Installation and Dependencies<a class="headerlink" href="#installation-and-dependencies"
                                                                title="Permalink to this heading">¶</a></h3>
                            <p>You can install the pvcException package through composer.:</p>
                            <div class="highlight-default notranslate">
                                <div class="highlight"><pre><span></span><span class="n">require</span> <span
                                        class="s2">&quot;pvc/err&quot;</span>
</pre>
                                </div>
                            </div>
                            <p>Note that the pvcException package requires pvcInterfaces, so you will see that show up
                                in your vendor/pvc directory. It
                                also requires Nikita Popov’s PHP Parser because there’s a spot in the code where is
                                necessary to parse php files in
                                order to extract the class string from a file.</p>
                        </section>
                        <section id="setup">
                            <h3>Setup<a class="headerlink" href="#setup" title="Permalink to this heading">¶</a></h3>
                            <ol class="arabic simple">
                                <li><p>Decide where you want to keep your exception code prefixes file. If you are using
                                    a framework that has a config directory, that would be a sensible choice, or simply
                                    perhaps in the root of your src directory.</p></li>
                                <li><p>as part of bootstrapping your application, use putenv() to set “XCodePrefixes” to
                                    the filepath chosen in step 1.</p></li>
                            </ol>
                            <p>Update this file as often as you create a new exception library. Recall that creating an
                                exception library
                                consists of</p>
                            <ul class="simple">
                                <li><p>creating the directory in which the exceptions live</p></li>
                                <li><p>creating a class inside that directory which extends pvc’s XDataAbstract class
                                    and stores “local” codes and messages.</p></li>
                                <li><p>create exceptions where the constructor consists of the parameter(s) to the
                                    message followed by any previous exception you are adding to the exception
                                    stack.</p></li>
                            </ul>
                        </section>
                        <section id="usage">
                            <h3>Usage<a class="headerlink" href="#usage" title="Permalink to this heading">¶</a></h3>
                            <p>This is ow to throw the exception:</p>
                            <div class="highlight-default notranslate">
                                <div class="highlight"><pre><span></span>throw new MyException($param1, $param2, $previous);
</pre>
                                </div>
                            </div>
                        </section>
                    </section>
                </section>


            </div>

        </div>
    </div>
    <div aria-label="main navigation" class="sphinxsidebar" role="navigation">
        <div class="sphinxsidebarwrapper">
            <h1 class="logo"><a href="#">pvcErr</a></h1>


            <h3>Navigation</h3>

            <div class="relations">
                <h3>Related Topics</h3>
                <ul>
                    <li><a href="#">Documentation overview</a>
                        <ul>
                        </ul>
                    </li>
                </ul>
            </div>
            <div id="searchbox" role="search" style="display: none">
                <h3 id="searchlabel">Quick search</h3>
                <div class="searchformwrapper">
                    <form action="search.html" class="search" method="get">
                        <input aria-labelledby="searchlabel" autocapitalize="off" autocomplete="off" autocorrect="off"
                               name="q" spellcheck="false" type="text"/>
                        <input type="submit" value="Go"/>
                    </form>
                </div>
            </div>
            <script>document.getElementById('searchbox').style.display = "block"</script>


        </div>
    </div>
    <div class="clearer"></div>
</div>
<div class="footer">
    &copy;2023, Doug Wilbourne.

    |
    Powered by <a href="http://sphinx-doc.org/">Sphinx 6.1.3</a>
    &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>

    |
    <a href="_sources/index.rst.txt"
       rel="nofollow">Page source</a>
</div>


</body>
</html>